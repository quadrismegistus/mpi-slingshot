#!/usr/bin/env python
import os,imp,argparse,sys
PATH_TO_SLINGSHOT = os.path.join(__file__,'slingshot.py')
sys.path.append(os.path.split(PATH_TO_SLINGSHOT)[0])

if __name__ == '__main__':
	# Load MPI 4 py
	os.system('module load py-mpi4py')

	# parse arguments
	parser = argparse.ArgumentParser()
	parser.add_argument('-sling',help="Path to the python or R file of code (ending in .py or .R)")
	parser.add_argument('-rock',help='The name of the function in the code that takes a string filepath')
	parser.add_argument('-pathlist',help='A text file with a path per line')
	parser.add_argument('-path',help='A directory where files ending with -ext EXT will be considered the paths [is recursive]')
	parser.add_argument('-ext',help='The file extension files in -path PATH must have in order to be considered')
	parser.add_argument('-limit',help='How many paths to process')
	parser.add_argument('-sbatch',help='Run on sherlock',action='store_true')
	parser.add_argument('-hours',help='How many hours to ask sherlock for',default=1)
	args = parser.parse_args()

	# Load slingshot
	if not args.sling or not args.rock:
		if not args.sling: print "error: -sling SLING must be specified"
		if not args.rock: print "error: -rock ROCK must be specified"
		print
		parser.print_help()
		sys.exit(1)

	# Construct Goliath
	path_ext=None
	if args.pathlist:
		path_source = args.pathlist
	elif args.path:
		path_source = args.path
		path_ext = args.ext if args.ext else None
	else:
		print "error: neither -pathlist PATHLIST nor -path PATH specified"
		parser.print_help()
		sys.exit(1)

	# Other options
	limit = int(args.limit) if args.limit else None

	# Execute!
	
	command = """python -c "import slingshot; slingshot(sling={sling}, rock={rock}, path_source={path_source},path_ext={path_ext},limit={limit})" """.format(
		rock=rock,
		path_source=path_source,
		path_ext=path_ext,
		limit=limit
	)

	print command
